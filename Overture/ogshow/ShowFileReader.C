#include "ShowFileReader.h"
#include "GenericDataBase.h"

#include OV_STD_INCLUDE(list)

// Include the next file so we can query to find the maximum number of open files
#include <sys/resource.h>


// const aString *pointerToAConstString;
typedef GenericDataBase *DBPointer;

//\begin{>ShowFileReaderInclude.tex}{\subsubsection{constructor}} 
ShowFileReader::
ShowFileReader(const aString & showFileName /* = nullString */ )
//----------------------------------------------------------------------
// /Description:
//    Create an object for reading show files (generated by Ogshow) and
//  optionally supply the name of the show file to open. A show file can
//  also be opened with the {\tt open} member function.
// /showFileName (input): name of an existing show file (if specified).
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  numberOfOpenFiles=0;
  frameNumberForGrid=-1;
  maximumNumberOfHeaderComments=20;
  maxNumberOfShowFiles=10;  // initially allocate pointers for this many files. This may increase.
  movingGridProblem=FALSE;

  maxNumberOfOpenFiles=25; // this will be changed in open(...)
  
  currentFrameSeries=0;
  numberOfSolutions=0;
  numberOfSequences=0;
  
  streamMode=false;
  
  // nnumberOfValidFiles = total number of valid show files (i.e. initial show file + sub-files)
  if( !dbase.has_key("numberOfValidFiles") ){ dbase.put<int>("numberOfValidFiles")=0; } // 

  // Since we may delete Grids that we read in, we need to turn off the linking of Mappings,
  // otherwise we may try to link to a Mapping that has been deleted.
  MappingRC::setDataBaseMode(MappingRC::doNotLinkMappings);

  showFileIsOpen=FALSE;
  if( showFileName!=nullString )
    open(showFileName);

  
  
}


ShowFileReader::
~ShowFileReader()
{
  close();
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{close}} 
int ShowFileReader::
close()
//----------------------------------------------------------------------
// /Description:
//    Close an open show file.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( showFileIsOpen )
  {
    delete [] headerComment;
    for( int n=0; n<maxNumberOfShowFiles; n++ )
    {
      if( showFile[n]!=NULL )
      {
        if( !showFile[n]->isNull() )
          showFile[n]->unmount();  // unmount the DataBase file *wdh* 050514 -- per Kyle for Jeff
        delete showFile[n];
      }
    }
    delete [] showFile;  showFile=NULL;
  }
  showFileIsOpen=false;
  return 0;
}

  

int ShowFileReader::
countNumberOfFramesAndSolutions( const int displayInfo /* =1 */ )
//----------------------------------------------------------------------------
//  Find out how many frames and solutions there are
//  Currently numberOfFrames == numberOfSolutions
// /displayInfo (input) : if not equal to zero output info about the parameters in the file.
//----------------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::countNumberOfFramesAndSolutions:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  // if the variable numberOfFrames exists then we use it, otherwise search for all frames
  // cout << "getNumberOfFrames...\n";
  numberOfSequences=0;
  
  frameSeriesInfo.resize(frameSeriesNames.size(),int(numItemsInSeries));
  frameSeriesInfo = 0;
  listOfGeneralParameters.resize(frameSeriesNames.size()+1); // add one because listOfGeneralParameters[0] is for the whole file
  if( showFile[numberOfShowFiles-1]==NULL || showFile[numberOfShowFiles-1]->isNull() )  
    openShowFile(numberOfShowFiles-1);

  int minNumberOfFrames=INT_MAX;
  int maxNumberOfFrames=0;
  for ( int fs=0; fs<frameSeriesNames.size(); fs++ )
  {
    HDF_DataBase frameSeries;

    showFile[numberOfShowFiles-1]->find(frameSeries,frameSeriesNames[fs],"frameSeries");
    assert(!frameSeries.isNull());
    HDF_DataBase dbGrid[1];
    aString names[1];
    // int maxNumber = 0;
    frameSeries.get(frameSeriesInfo(fs,numFrames),"numberOfFrames" );
    frameSeries.get(frameSeriesInfo(fs,numSequences),"numberOfSequences" );
    frameSeries.get(frameSeriesInfo(fs,isMovingGrid),"movingGridProblem");
    frameSeries.get(frameSeriesInfo(fs,streamModeOption),"streamMode");
      
    minNumberOfFrames=min(minNumberOfFrames,frameSeriesInfo(fs,numFrames));
    maxNumberOfFrames=max(maxNumberOfFrames,frameSeriesInfo(fs,numFrames));

    const int myid = max(0,Communication_Manager::My_Process_Number);
    if( displayInfo && myid==0 )
    {
      cout << "FrameSeries : "<<frameSeriesNames[fs]<<" : "<<frameSeriesInfo(fs,numFrames)<< " frames, "
           <<frameSeriesInfo(fs,numSequences)<<" sequences found , "
           <<(frameSeriesInfo(fs,isMovingGrid)? " is a moving grid problem" : "is not a moving grid problem")<<endl;
    }
    frameSeriesInfo(fs,numSolutions)=frameSeriesInfo(fs,numFrames); 
  }
  if( minNumberOfFrames!=maxNumberOfFrames )
  {
    // For restarts of multi-domain problems the last solutoion should correspond to the common
    // last solution in the different frame series. *wdh* 2013/01/28
    printF("ShowFileReader::WARNING: Not all frame series have the same number of frames "
           " (maybe the last file was not closed properly).\n"
           "  I am going to change the number of frames to the common minimum = %i.\n",minNumberOfFrames);
    for ( int fs=0; fs<frameSeriesNames.size(); fs++ )
    {
      frameSeriesInfo(fs,numFrames)= minNumberOfFrames;
    }
    
  }
  

  // -- This next call set numberOfFrames: 
  setCurrentFrameSeries(0);

  // printF("countNumberOfFramesAndSolutions: numberOfFrames=%i\n",numberOfFrames);
  return numberOfFrames;
  
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getNumberOfFrames}} 
int ShowFileReader::
getNumberOfFrames() const
//----------------------------------------------------------------------
// /Description:
//    Returns the number of frames that exist in the show file for the furrent frame series. 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getNumberOfFrames:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  return numberOfFrames;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getNumberOfSolutions}} 
int ShowFileReader::
getNumberOfSolutions() const
//----------------------------------------------------------------------
// /Description:
//    Returns the number of Solutions that exist in the show file for the furrent frame series. 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getNumberOfSolutions:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  return numberOfSolutions;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getNumberOfSequences}} 
int ShowFileReader::
getNumberOfSequences() const
//----------------------------------------------------------------------
// /Description:
//    Returns the number of Sequences that exist in the show file for the furrent frame series. 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getNumberOfSequences:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  if( frameSeriesNames.size()>0 )
    return frameSeriesInfo(currentFrameSeries,numSequences); // *wdh* 090602
  else
    return numberOfSequences;
}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{setMaximumNumberOfOpenShowFiles}} 
void ShowFileReader::
setMaximumNumberOfOpenShowFiles(const int maxNumber )
// ==============================================================================================
// /Description:
// For very large files we may have to reduce the number of files that we allow to be open at any time
// 
//\end{ShowFileReaderInclude.tex}
// ==============================================================================================
{
  // get the maximum number of allowable open file descriptors: 
  rlimit rlim;
  getrlimit(RLIMIT_NOFILE,&rlim);

  maxNumberOfOpenFiles=min(max(3,maxNumber),rlim.rlim_cur);  // must keep at least 3 open
}



int ShowFileReader::
getNumberOfValidFiles( const int displayInfo /* =1 */ )
// ==================================================================
// This may be a multi-file showfile, so look for all sub-files
// /displayInfo (input) : if not equal to zero output info about the parameters in the file.
//
// return value: number of show files that were found.
// ==================================================================
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getNumberOfValidFiles:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  numberOfShowFiles=1;
  char buff[80];
  int n;
  const int maxFiles=100000; 
  for( n=1; n<maxFiles; n++ )
  {
    aString name = nameOfShowFile + sPrintF(buff,"%i",n);
    FILE *fp = fopen((const char *)name,"r");
    if( fp!=NULL )
    {
      // cout << "subfile exists named: " << name << endl;
      numberOfShowFiles=n+1;
      fclose(fp);
    }
    else
    {
      break;
    }
  }
  if( displayInfo )
  {
    if( numberOfShowFiles>1 )
      printF("ShowFileReader:INFO: %i show files found\n",numberOfShowFiles);
  }
  
  if( numberOfShowFiles==(maxFiles-1) )
  {
    printF("ShowFileReader:WARNING: %i show files found. There may be even more\n",numberOfShowFiles);
  }
  if( numberOfShowFiles >= maxNumberOfShowFiles )
  {
    // we need to allocate space for more show files.
    GenericDataBase **oldShowFile = showFile;
    showFile = new DBPointer [numberOfShowFiles];
    for( n=0; n<maxNumberOfShowFiles; n++ )
      showFile[n]=oldShowFile[n];
    for( n=maxNumberOfShowFiles; n<numberOfShowFiles; n++ )
      showFile[n]=NULL;

    maxNumberOfShowFiles=numberOfShowFiles;

    delete [] oldShowFile;
  }
  // now find the last valid file, the "magicNumber" in the subfile must match
  // the magicNumber in the first file. If not, the subfile probably came from 
  // a previous run.
  int magicNumber=-1;
  showFile[0]->turnOffWarnings();
  showFile[0]->get(magicNumber,"magicNumber");
  showFile[0]->turnOnWarnings();
  
  int last = numberOfShowFiles-1;
  while( last>0 )
  {
    if( openShowFile(last)==0 )
    {
      int magic=0;
      showFile[last]->turnOffWarnings();
      showFile[last]->get(magic,"magicNumber");
      showFile[last]->turnOnWarnings();
      // printf("subfile %i, magic=%i, ==? magicNumber=%i \n",last,magic,magicNumber);
      if( magic==magicNumber )   // this is a valid sub-file
        break;
      // remove this invalid subfile
      showFile[last]->unmount();
      delete showFile[last];  
      showFile[last]=0;
      numberOfOpenFiles--;
    }
    last--;
  }
  if( last<numberOfShowFiles-1 )
  {
    printF("ShowFileReader:: The show files named `%s',...,'%s' are invalid. You may want to delete them. \n",
           (const char*)(nameOfShowFile + sPrintF(buff,"%i",last+1)),
           (const char*)(nameOfShowFile + sPrintF(buff,"%i",numberOfShowFiles-1)));
  }    
  numberOfShowFiles=last+1;

  //kkc 061020 get the frame series list
  HDF_DataBase fs_dbt[1];
  aString fs_namest[1];
  int numberOfFrameSeries=0;

  showFile[numberOfShowFiles-1]->find(fs_dbt,fs_namest,"frameSeries",0,numberOfFrameSeries);
  if ( numberOfFrameSeries ) {
    HDF_DataBase *fs_db;
    aString *fs_names;
    fs_names = new aString[numberOfFrameSeries];
    fs_db = new HDF_DataBase[numberOfFrameSeries];
    showFile[numberOfShowFiles-1]->find(fs_db,fs_names,"frameSeries",numberOfFrameSeries,numberOfFrameSeries);
    frameSeriesNames.resize(numberOfFrameSeries);
    for ( int s=0; s<numberOfFrameSeries; s++ )
    {
      HDF_DataBase fsdb;
      showFile[numberOfShowFiles-1]->find(fsdb,fs_names[s],"frameSeries");
      int id=0;
      fsdb.get(id,"id");
      frameSeriesNames[id]=fs_names[s];

      // printF("Found Frame Series : %s with id=%i\n",(const char*)frameSeriesNames[id],id);
    }
    delete [] fs_db;
    delete [] fs_names;
  }

  return numberOfShowFiles;
}

void ShowFileReader::
checkSolutionNumber(const aString & routineName, int & solutionNumber )
{
  if( solutionNumber<=0 || solutionNumber>numberOfSolutions )
  {
    printF("%s:ERROR: solution number= %i should be in the range [1,%i]\n",
            (const char*)routineName,solutionNumber,numberOfSolutions);
    solutionNumber=max(1,min(solutionNumber,numberOfSolutions));
    printF(" choosing solution = %i\n",solutionNumber);
  }
}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getAGrid}} 
ShowFileReader::ReturnType ShowFileReader::
getAGrid(MappedGrid & mg, 
         int & solutionNumber, 
         int frameForGrid /* =useDefaultLocation */ )
//----------------------------------------------------------------------
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  CompositeGrid cg;
  ReturnType returnValue;
  returnValue=getAGrid( cg,solutionNumber,frameForGrid);
  mg.reference(cg[0]);
  return returnValue;
}


//\begin{>>ShowFileReaderInclude.tex}{}
ShowFileReader::ReturnType ShowFileReader::
getAGrid(GridCollection & cg, 
         int & solutionNumber, 
         int frameForGrid /* =useDefaultLocation */ )
//----------------------------------------------------------------------
// /Description:
//   Get grid GridCollection or CompositeGrid from a show file. If this a moving grid problem then return the grid
//    corresponding to a give solutionNumber.
// /cg (output): The grid corresponding to the solution numbered {\tt solutionNumber}. This
//   routine will always read in a new grid if a grid is found.
// /solutionNumber (input): For moving grid problems only.
//   Find the grid corresponding to this solution number. 
//   This number should be
//   in the range [1,numberOfSolutions], where numberOfSolutions is the value by getNumberOfSolutions()
//   If solutionNumber is out of range then the closest valid solution number is chosen, and this value
//   is returned in solutionNumber.  Thus if you want to get the last grid in the file choose
//   solutionNumber to be any integer that is larger than the number of solutions in the file.
// /frameForGrid : indicates where in the show file the grid for this solution can be found.
//     useDefaultLocation : use default location (frame 1 for non-moving grids or the current frame
//    for moving grids), useCurrentFrame : current frame, $>0$ : specify a frame number. 
// /return values: notFound or gridFound.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getAGrid:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }

  int debug=0;  // 3 
  
  if( numberOfFrames <= 0 )
  {
    int numberOfGrids;
    const int maxNumber=10;
    HDF_DataBase dbGrid[maxNumber];
    aString names[maxNumber];
    showFile[0]->find(dbGrid,names,"CompositeGridData",maxNumber,numberOfGrids );
    if( numberOfGrids > 0 )
    {
      printF("plotStuff:getAGrid: no frames found but grids are there! \n");
      int grid =max(0,min(solutionNumber,min(numberOfGrids,maxNumber))-1);

      // printf(" names[0]=%s \n",(const char*)names[0]);
      if( names[0]=="decompressed" )
      {
        printF("***** decompressed file found ******\n");
        showFile[0]->setMode(GenericDataBase::noStreamMode);
      }
      
      cg.get(*showFile[0],names[grid]);
      return gridFound;
    }  
    else
    {
      // this may be an Xcog or chalmesh file
      int found = getFromADataBase((CompositeGrid&)cg,nameOfShowFile);
      if( found==0 )
       return gridFound; 
      else
      {
        printF("ShowFileReader:getAGrid: Error: there are no frames and no grids in this file! \n");
        Overture::abort("error");
      }
    }
  }

  checkSolutionNumber("getAGrid",solutionNumber);
  
  // If there are multiple frames in this file, find the grid corresponding to a given solution

  HDF_DataBase cgDir;
  char frameName[20];

  int numberOfFramesPerFile;
  // int fileNumber=0;
  int gridSolutionNumber=solutionNumber;
  
  if( !isAMovingGrid() && frameForGrid==useDefaultLocation )
  {
    gridSolutionNumber=1;  // ******* non moving grid, get grid for solution number 1
  }
  else if( numberOfShowFiles >1  && showFile[0]->get(numberOfFramesPerFile,"numberOfFramesPerFile")== 0 )
  { // there are multiple show files, open the correct one
    // cout << "numberOfFramesPerFile=" << numberOfFramesPerFile << endl;
    
    if( frameForGrid==useCurrentFrame || frameForGrid==useDefaultLocation )
      gridSolutionNumber=solutionNumber;
    else 
      gridSolutionNumber=frameForGrid;
    
    //kkc 061023    fileNumber=(gridSolutionNumber-1)/numberOfFramesPerFile    ;
    //kkc 061023    if( showFile[fileNumber]==NULL || showFile[fileNumber]->isNull() )
    //kkc 061023      openShowFile(fileNumber);
  }
  // open the appropriate frame
  sPrintF(frameName,"frame%i",gridSolutionNumber);

  //kkc 061023    assert( fileNumber>=0 );
  
  //  showFile[fileNumber]->find(currentFrame,frameName,"frame");
  getFrame(gridSolutionNumber); // kkc 061023
  

  // Always look for a grid.
  if( currentFrame.locate(cgDir,"CompositeGrid","CompositeGridData")==0  )
  {
    cg.get(currentFrame,"CompositeGrid");
    if( debug & 2 )
      printF("ShowFileReader:getAGrid: solutionNumber=%i, get a new CompositeGrid, numberOfComponentGrids=%i\n",
             solutionNumber-1,cg.numberOfComponentGrids());
  }
  else if( currentFrame.locate(cgDir,"GridCollection","GridCollectionData")==0 )
  {
    cg.get(currentFrame,"GridCollection");
    if( debug & 2 )
      printF("ShowFileReader:getAGrid: solutionNumber=%i, get a new GridCollection, numberOfComponentGrids=%i\n",
             solutionNumber-1,cg.numberOfComponentGrids());
  }
  else 
  {
    if( isAMovingGrid() )
      printF("ShowFileReader:getAGrid:ERROR: This is a show file from a moving grid computation but\n"
        " no grid found on frame = %i\n",frameNumberForGrid);
    else
      printF("ShowFileReader:getAGrid:ERROR: no grid found on frame = %i\n",frameNumberForGrid);
    return notFound;
  }
  
  frameNumberForGrid=gridSolutionNumber;

  currentFrame.turnOffWarnings();
  numberOfHeaderComments=currentFrame.get(headerComment,"header",maximumNumberOfHeaderComments);
  currentFrame.turnOnWarnings();

  // kkc 071207 
  if ( frameNumberForGrid != solutionNumber ) getFrame(solutionNumber);
  return gridFound;

}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getHeaderComments}} 
const aString* ShowFileReader::
getHeaderComments(int & numberOfHeaderComments0)
//----------------------------------------------------------------------
// /Description:
//   Get header comments for the last grid or solution that was found
// /numberOfHeaderComments0 (output): The number of comments in the array of Strings 
// /return value: An array of aString's with the comments that are associated
//    with this solution. (You might use the declaration {\tt const aString *headerComment}).
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  numberOfHeaderComments0=numberOfHeaderComments;
  return headerComment;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getASolution}} 
ShowFileReader::ReturnType ShowFileReader::
getASolution(int & solutionNumber,
             MappedGrid & mg,
             realMappedGridFunction & u)
//----------------------------------------------------------------------
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  CompositeGrid cg;   // ****** fix this when mg exists! *********
  realCompositeGridFunction uCG;
  ReturnType returnValue=getASolution( solutionNumber,cg,uCG );
  mg.reference(cg[0]);
  u.reference(uCG[0]);
  return returnValue;
}


//\begin{>>ShowFileReaderInclude.tex}{}
ShowFileReader::ReturnType ShowFileReader::
getASolution(int & solutionNumber,
             GridCollection & cg,
             realGridCollectionFunction & u)
//----------------------------------------------------------------------
// /Description:
//   Get grid (GridCollection or CompositeGrid) and a grid function (realGridCollectionFunction
//   or realCompositeGridFunction) from a show file.
// /solutionNumber (input/ouptut): The number of the solution to get. This number should be
//   in the range [1,numberOfSolutions], where numberOfSolutions is the value by getNumberOfSolutions()
//   If solutionNumber is out of range then the closest valid solution number is chosen, and this value
//   is returned in solutionNumber.  Thus if you want to get the last solution in the file choose
//   solutionNumber to be any integer that is larger than the number of solutions in the file.
// /cg (input/output): The grid corresponding to the solution numbered {\tt solutionNumber}. 
//    The grid cg will only be changed under certain circumstances. 
//    The grid cg will be created or changed in the following cases:
//    \begin{itemize}
//      \item cg is a null grid on input.
//      \item The show file contains moving grids and solutionNumber is not equal to the
//            solutionNumber of the last time this routine was called.
//    \end{itemize}
// /u (output): The grid function corresponding to the solution numbered {\tt solutionNumber}
// /return values: notFound or gridFound or solutionFound or solutionAndGridFound.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::getASolution:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }
  ReturnType gridWasFound=notFound;
  // 
  // frameNumberForGrid is a variable that remembers the frameNumber from which the grid was found
  // on a previous call

//   printF("++ShowFileReader::getASolution: frameSeries=%i isAMovingGrid=%i frameNumberForGrid=%i solutionNumber=%i\n",
//       currentFrameSeries,isAMovingGrid(),frameNumberForGrid,solutionNumber);
  
  if( cg.numberOfComponentGrids()==0 || ( isAMovingGrid() &&  frameNumberForGrid!=solutionNumber) ) 
  {
    if( isAMovingGrid() )
      printF("**ShowFileReader::getASolution:get a new moving grid: frameSeries=%i, solutionNumber=%i\n",
              currentFrameSeries,solutionNumber);
    
    gridWasFound = getAGrid(cg,solutionNumber);
  }

  if( numberOfFrames <= 0 )
  {  // this show file has no solutions, could be a grid file
    u=1.;
    return gridWasFound;
  }
  checkSolutionNumber("getAGrid",solutionNumber);

  //  --- look up the frame in which the solution sits (currentFrame)
  getFrame(solutionNumber); 

  currentFrame.turnOffWarnings();
  numberOfHeaderComments=currentFrame.get(headerComment,"header",maximumNumberOfHeaderComments);
  currentFrame.turnOnWarnings();

  if( !isAMovingGrid() )
  { 
    // char frameName[20];
    // int numberOfFramesPerFile;
    // int fileNumber=0;
  
    int frameForGrid=frameNumberForGrid;
    int found=currentFrame.get(frameForGrid,"frameForGrid");
    // printF("****ShowFileReader: found=%i, frameForGrid=%i frameNumberForGrid=%i\n",
    //        found,frameForGrid,frameNumberForGrid);
    
    if( !isAMovingGrid() && frameForGrid!=frameNumberForGrid )
    {
      printF("--SFR-- read in a new grid for solutionNumber=%i (frameForGrid=%i) \n",
             solutionNumber,frameForGrid);

      gridWasFound = getAGrid(cg,solutionNumber,frameForGrid);
      if( gridWasFound )
      {
        printF("--SFR-- new grid found, numberOfComponentGrids=%i\n",cg.numberOfComponentGrids());
      }
      
      if( !gridWasFound )
        printF(" ShowFileReader:ERROR: no grid found?! \n");
    }
  }
  
  u.updateToMatchGrid(cg);   // ****** really should only have to set the grid here ******
  int found = u.get(currentFrame,"u");

  int solutionWasFound = found!=0 ? 0 : solutionFound;
  if( !solutionWasFound )
  {
    u=1.;
    if( numberOfFrames > 0 )
      printF("ShowFileReader:getASolution:ERROR no solution found on frame = %i\n",solutionNumber);
  }
  
  if( (bool)solutionWasFound && (bool)gridWasFound )
    return solutionAndGridFound;
  else if( solutionWasFound )
    return solutionFound;
  else if( gridWasFound )
    return gridFound;
  else
    return notFound;

}
// =========================================================================================
/// \brief This utility routine will find which frames are in which files and save the
///  results in the array fileNumberForFrame
///
/// \notes fileNumberForFrame[frameNumber] = subFile where frame is found 
// =========================================================================================
int ShowFileReader::
locateFramesInFiles()
{
  if( !dbase.has_key("fileNumberForFrame") )
   dbase.put<vector<int> >("fileNumberForFrame");

  std::vector<int> & fileNumberForFrame = dbase.get<vector<int> >("fileNumberForFrame");

  fileNumberForFrame.resize(numberOfFrames);

  printF("--SFR-- locateFramesInFiles: frames are not in standard order (restart?). Make a list:");
  int frame=0;
  for( int fileNumber=0; fileNumber<numberOfShowFiles; fileNumber++ )
  {
    if( showFile[fileNumber]==NULL || showFile[fileNumber]->isNull() )
      openShowFile(fileNumber);

    int numFrames=0;
    showFile[fileNumber]->get(numFrames,"numberOfFrames");
    // printF("--SFR-- file=%i, frames-so-far = %i\n",fileNumber,numFrames);
    for( int f=frame; f<numFrames; f++ )
    {
      fileNumberForFrame[f]=fileNumber;
      printF("        frame %i is in file %i\n",f,fileNumber);
    }
    frame=numFrames;
  }
  return 0;
}



//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getFrame}} 
HDF_DataBase* ShowFileReader::
getFrame(int solutionNumber /* = -1 */)
// ====================================================================================
//   /Description:
//     Return a pointer to the data base directory holding a frame; by default the current frame.
//     You could use this pointer to get any additional data that has been saved in the frame.
//     The current frame for all other calls is also set to the requested frame number.
//      In the following example some extra data in the form of a realArray is retrieved.
//    \begin{verbatim}
//       ShowFileReader show(...);
//       ...
//       show.getASolution(...);
//       realArray myData;
//       show.getFrame()->get(myData,"my data");
//       ...
//    \end{verbatim}
//  /solutionNumber (input): get the frame for this solution number. If no argument is specified then
//    return the current frame. 
//  /Return value: Return a pointer to the data base directory holding the frame, possibly NULL.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  if( solutionNumber>0 )
  {
    checkSolutionNumber("getAGrid",solutionNumber);
    // open the appropriate frame
    char frameName[20];

    int fileNumber=0, numberOfFramesPerFile;
    HDF_DataBase frameSeriesDB;
    bool found = false;
    sPrintF(frameName,"frame%i",solutionNumber);

    // *wdh* 070630 -- to be more efficient first look for the frame assuming a fixed number
    //  of frames per file.
    if( numberOfShowFiles >1  && showFile[0]->get(numberOfFramesPerFile,"numberOfFramesPerFile")== 0 )
    {
      // *wdh* 2013/01/28 -- adjust file number by number of frame series
      // fileNumber=(solutionNumber-1)*/numberOfFramesPerFile;

      const int numberOfFrameSeries=frameSeriesNames.size();
      if( dbase.has_key("fileNumberForFrame") )
      {
        // If the fileNumberForFrame list has been constructed then use it:
        //   fileNumberForFrame[frameNumber] = subFile where frame is found 
        std::vector<int> & fileNumberForFrame = dbase.get<vector<int> >("fileNumberForFrame");
        fileNumber =fileNumberForFrame[solutionNumber-1];
      }
      else
      {
        // By default we can often compute the sub-file where the frame is found. 
        const int fileSolution = (solutionNumber-1)*numberOfFrameSeries+currentFrameSeries;
        fileNumber= min( (fileSolution)/numberOfFramesPerFile, numberOfShowFiles-1);
      }
      
      assert( fileNumber<numberOfShowFiles );

      if( showFile[fileNumber]==NULL || showFile[fileNumber]->isNull() )
        openShowFile(fileNumber);
      if ( showFile[fileNumber]->locate(frameSeriesDB,frameSeriesNames[currentFrameSeries],"frameSeries")==0 )
        found = frameSeriesDB.locate(currentFrame,frameName,"frame")==0;

      if( false )
        printF("ShowFileReader::getFrame: Look for solution %i in fileNumber=%i : found=%i "
               "(numberOfFramesPerFile=%i,numberOfFrameSeries=%i)\n",solutionNumber,fileNumber,(int)found,
               numberOfFramesPerFile,numberOfFrameSeries);

      if( 1==0 && found )
        printF("--SFR-- getFrame: solution %i found in file %i.\n",solutionNumber,fileNumber);
    }

    if( !found )
    {
      // --- Search for a frame when showFiles have different numbers of frames per file ---

      if( true )
      {
        // -- new way: *wdh* 2015/09/08
        // construct a list of where frames are located

        if( !dbase.has_key("fileNumberForFrame") )
        { 
          locateFramesInFiles();  // this call will build the list fileNumberForFrame
        }
        // fileNumberForFrame[frameNumber] = subFile where frame is found 
        std::vector<int> & fileNumberForFrame = dbase.get<vector<int> >("fileNumberForFrame");
        fileNumber =fileNumberForFrame[solutionNumber-1];

        if( showFile[fileNumber]==NULL || showFile[fileNumber]->isNull() )
          openShowFile(fileNumber);

        if ( showFile[fileNumber]->locate(frameSeriesDB,frameSeriesNames[currentFrameSeries],"frameSeries")==0 )
          found = frameSeriesDB.locate(currentFrame,frameName,"frame")==0;

        if( found )
        {
          if( 1==0 )
            printF("--SFR-- getFrame: solution %i found in file %i.\n",solutionNumber,fileNumber);
        }
        else
        {
          printF("--SFR-- getFrame:ERROR solution %i NOT found in file %i (from list).\n",solutionNumber,fileNumber);
          OV_ABORT("ERROR -- this should not happen");
        }
        
      }
      else
      {
        // *old way*
        fileNumber=0;
        while ( fileNumber<numberOfShowFiles && !found )
        {// kkc 061023 this will be less efficient when there are lots of show files,
          //           but it also works if the number of frames per file is changed on the fly
          if( showFile[fileNumber]==NULL || showFile[fileNumber]->isNull() )
            openShowFile(fileNumber);

          if ( showFile[fileNumber]->locate(frameSeriesDB,frameSeriesNames[currentFrameSeries],"frameSeries")==0 )
            found = frameSeriesDB.locate(currentFrame,frameName,"frame")==0;

          if( found )
            printF("ShowFileReader::getFrame: solution %i found in file %i (after search).\n",solutionNumber,fileNumber);

          fileNumber++;
        }
      }
      
    }
    
    if ( !found ) 
    {
      cerr<<"ShowFileReader::getFrame::ERROR : could not find "<<frameName<<" in frame series "<<
             frameSeriesNames[currentFrameSeries]<<endl;
      Overture::abort("error");
    }
  }
  
  if( currentFrame.isNull() )
  {
    printF("ShowFileReader::getFrame::ERROR: the current frame is NULL !\n");
    Overture::abort("error");
  }
  return &currentFrame;
}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getSequenceNames}} 
int ShowFileReader::
getSequenceNames(aString *name, int maximumNumberOfNames)
// ====================================================================================
//   /Description:
//     Return the names of the sequences, up to a maximum of maximumNumberOfNames,
//  /Return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  // printF("ShowFileReader::getSequenceNames: numberOfSequences=%i\n",numberOfSequences);
  
  for( int sequenceNumber=0; sequenceNumber<min(numberOfSequences,maximumNumberOfNames); sequenceNumber++ )
  {
    HDF_DataBase sequence;
    char buff[80];
    int last = numberOfShowFiles-1;

    HDF_DataBase frameSeriesDB;
    showFile[last]->locate(frameSeriesDB,frameSeriesNames[currentFrameSeries],"frameSeries");
    int rt = frameSeriesDB.locate(sequence,sPrintF(buff,"sequence%i",sequenceNumber),"sequence"); 
    if( rt==0 )
    {
      sequence.get(name[sequenceNumber],"name");
      // printF("ShowFileReader::getSequenceNames: sequence %i : name=[%s]\n",sequenceNumber,
      //        (const char *)name[sequenceNumber]);
    }
    else
    { // backup way to find sequences
      printF("ShowFileReader::getSequenceNames: sequence %i : UNABLE to find (new way)\n",sequenceNumber);

      HDF_DataBase *dbSeq = new HDF_DataBase[numberOfSequences];
      aString *seqNames = new aString [numberOfSequences];
      int maxNumber=numberOfSequences;
      frameSeriesDB.find(dbSeq,seqNames,"sequence",maxNumber,numberOfSequences );


      for( int s=0; s<min(numberOfSequences,maximumNumberOfNames); s++ )
      {
        dbSeq[s].get(name[s],"name");
        printF("ShowFileReader::getSequenceNames: OLD WAY: sequence %i : seq=[%s] name=[%s]\n",s,
               (const char*)seqNames[s], (const char *)name[s]);
      }
      
      delete [] dbSeq;
      delete [] seqNames;
      
      break;
    }
    
  }
  return 0;
  
}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getSequence}} 
int ShowFileReader::
getSequence(int sequenceNumber,
            aString & name, RealArray & time, RealArray & value, 
            aString *componentName1, int maxComponentName1,
            aString *componentName2, int maxComponentName2)
// ====================================================================================
//   /Description:
//     Return the data for a sequence.
//
// /name (output) : name of the sequence.
// /time (output) : time(0...n-1) - array of n 'time' values or other iteration variable.
// /value (output) : value(0...n-1,0..m-1) array of n values for each of m components.
// /componentName1 (output) : name1[0..m-1] name for the components.
// /maxComponentName1 (input) : maximum number of array elements in the array componentName1.
// /componentName2 (output) : names for a second level of components BUT DO NOT USE THIS for now.
// /maxComponentName2 (input) : maximum number of array elements in the array componentName2.
//
//  /Return value: 0 for success.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  if( sequenceNumber>=0 && sequenceNumber<numberOfSequences )
  {
    HDF_DataBase sequence;
    char buff[80];
    int last = numberOfShowFiles-1;

    HDF_DataBase frameSeriesDB;
    showFile[last]->locate(frameSeriesDB,frameSeriesNames[currentFrameSeries],"frameSeries");
    int rt = frameSeriesDB.locate(sequence,sPrintF(buff,"sequence%i",sequenceNumber),"sequence"); 

    if( rt!=0 )
    { // backup way to find sequences
      HDF_DataBase *dbSeq = new HDF_DataBase[numberOfSequences];
      aString *seqNames = new aString [numberOfSequences];
      int maxNumber=numberOfSequences;
      frameSeriesDB.find(dbSeq,seqNames,"sequence",maxNumber,numberOfSequences );

      sequence = dbSeq[sequenceNumber];
      
      if( false )
      {
        for( int s=0; s<numberOfSequences; s++ )
        {
          aString sname; 
          dbSeq[s].get(sname,"name");
          printF(" ShowFileReader::getSequence: seqNames[%i]=[%s] name=[%s]\n",s,(const char*)seqNames[s],
                    (const char*)sname);
        }
      }
        
      delete [] dbSeq;
      delete [] seqNames;
    }
    
    sequence.get(name,"name");
    sequence.get(time,"time"); // allocate time first?
    sequence.get(value,"value");    
    sequence.get(componentName1,"componentName0",maxComponentName1);   
    sequence.get(componentName2,"componentName1",maxComponentName2);   

    return 0;

  }
  else
  {
    return 1;
  }
  
}
  

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getGeneralParameters}} 
int ShowFileReader::
getGeneralParameters( const int displayInfo /* =1 */ )
//----------------------------------------------------------------------
// /Description:
//    Get the list of parameters that go with this file.
// /displayInfo (input) : if not equal to zero output info about the parameters in the file.
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  const int first = 0;  // find general parameters in this first show file

  for ( int fs=0; fs<frameSeriesNames.size()+1; fs++ )
  {
    HDF_DataBase paramsDB;
    if ( !fs ) 
      paramsDB = *showFile[first];
    else
      showFile[first]->find(paramsDB,frameSeriesNames[fs-1],"frameSeries");

    if( displayInfo )
      printF("ShowFileReader : getting general parameters for %s\n",
             (fs ? (const char*)frameSeriesNames[fs-1] : "root directory"));
    
    int numberOfParameters=-1;
    paramsDB.turnOffWarnings();
    int returnValue = paramsDB.get(numberOfParameters,"numberOfGeneralParameters");
    paramsDB.turnOnWarnings();
    if( returnValue!=0 || numberOfParameters<=0 ) continue;
      
    // For now every parameter is potentially stored as an int, real or string
      
    int *type = new int [numberOfParameters];
    aString *name = new aString [numberOfParameters];  
    int *iv = new int [numberOfParameters];
    real *rv = new real [numberOfParameters];
    aString *sv = new aString [numberOfParameters];
      
    paramsDB.get(name,"generalParameterName",numberOfParameters);
    paramsDB.get(type,"generalParameterType",numberOfParameters);
    paramsDB.get(iv,"generalParameterInt",numberOfParameters);
    paramsDB.get(rv,"generalParameterReal",numberOfParameters);
    paramsDB.get(sv,"generalParameterString",numberOfParameters);
      
    listOfGeneralParameters[fs].clear();
    ShowFileParameter sfp;
    for(int i=0; i<numberOfParameters; i++ )
    {
      if( displayInfo )
      {
        printF("ShowFile: parameter %i: name=%s value=",i,(const char*)name[i]);
        if( type[i]==(int)ShowFileParameter::intParameter )
          printF("%i\n",iv[i]);
        else if( type[i]==(int)ShowFileParameter::realParameter )
          printF("%e\n",rv[i]);
        else
          printF("%s\n",(const char*)sv[i]);
      }
      
      sfp.set(name[i],(ShowFileParameter::ParameterType)type[i],iv[i],rv[i],sv[i]);
      listOfGeneralParameters[fs].push_back(sfp);
    }

    delete [] type;
    delete [] name;
    delete [] iv;
    delete [] rv;
    delete [] sv;
      
    if( displayInfo )
    {
      if ( fs )
        printF(" %i general parameters were found in frame series %s\n",numberOfParameters,frameSeriesNames[fs-1].c_str());
      else
        printF(" %i general parameters were found in the show file\n",numberOfParameters);
    }
  }

  return 0;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getGeneralParameter(int)}} 
bool ShowFileReader::
getGeneralParameter(const aString & name, int & ivalue,const Ogshow::PlaceToSaveGeneralParameters placeToSave ) 
//----------------------------------------------------------------------
// /Description:
//    Get a general parameter with type `int'
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  real rvalue;
  aString stringValue;
  return getGeneralParameter(name,ShowFileParameter::intParameter,ivalue,rvalue,stringValue,placeToSave);
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getGeneralParameter(int)}} 
bool ShowFileReader::
getGeneralParameter(const aString & name, real & rvalue,const Ogshow:: PlaceToSaveGeneralParameters placeToSave ) 
//----------------------------------------------------------------------
// /Description:
//    Get a general parameter with type `int'
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  int ivalue;
  aString stringValue;
  return getGeneralParameter(name,ShowFileParameter::realParameter,ivalue,rvalue,stringValue,placeToSave);
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getGeneralParameter(int)}} 
bool ShowFileReader::
getGeneralParameter(const aString & name, aString & stringValue,const Ogshow::PlaceToSaveGeneralParameters placeToSave ) 
//----------------------------------------------------------------------
// /Description:
//    Get a general parameter with type `int'
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  int ivalue;
  real rvalue;
  return getGeneralParameter(name,ShowFileParameter::stringParameter,ivalue,rvalue,stringValue,placeToSave);
}


//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getGeneralParameter(int)}} 
bool ShowFileReader::
getGeneralParameter(const aString & name, ShowFileParameter::ParameterType type, int & ivalue, real & rvalue, 
                    aString & stringValue,const Ogshow::PlaceToSaveGeneralParameters placeToSave ) 
//----------------------------------------------------------------------
// /Description:
//    Get a general parameter with the given name and type
// /name, type (input) : get the parameter value for a parameter with this name and type.
// /ivalue (output) : return integer parameters in this variable (if type==intParameter)
// /rvalue (output) : return real parameters in this variable (if type==realParameter)
// /stringValue (output) : return string parameters in this variable (if type==stringParameter)
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{

  ListOfShowFileParameters &generalParameters = 
    placeToSave==Ogshow::THECurrentFrameSeries ? listOfGeneralParameters[currentFrameSeries+1] : 
                                                 listOfGeneralParameters[0];
  std::list<ShowFileParameter>::iterator iter; 
  for(iter = generalParameters.begin(); iter!=generalParameters.end(); iter++ )
  {
    if( iter->getName()==name )
      break;
  }
  if( iter==generalParameters.end() )
  {
    if( false )
    {
      printF("ShowFileReader::getGeneralParameter:WARNING: name=%s was not found. currentFrameSeries=%i, "
             "placeToSave=%s\n",
             (const char*)name,currentFrameSeries, (placeToSave==Ogshow::THECurrentFrameSeries ?
                                                    "current frame series" : "root"));
    }
    return false;  // not found
  }

  ShowFileParameter & sfp = *iter;
  
  ShowFileParameter::ParameterType typeFound = sfp.getType();
  if( type==typeFound )
  {
    aString pname;
    sfp.get(pname,type,ivalue,rvalue,stringValue);
  }
  else 
  {
    printF("ShowFileReader::getGeneralParameter:WARNING: name=%s found but it is not type=%i (typeFound=%i)\n",
           (const char*)name,type,typeFound);
    return false;
  }

  return true;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getListOfGeneralParameters}} 
ListOfShowFileParameters& 
ShowFileReader::getListOfGeneralParameters( 
  const Ogshow::PlaceToSaveGeneralParameters placeToSave /* =Ogshow::THECurrentFrameSeries */ )
//----------------------------------------------------------------------
// /Description:
// Return the general parameters
// 
// /placeToSave (input): define which list to use.
// 
// /return value: The list of show file parameters
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  ListOfShowFileParameters &generalParameters = 
    placeToSave==Ogshow::THECurrentFrameSeries ? listOfGeneralParameters[currentFrameSeries+1] : 
    listOfGeneralParameters[0];
  return generalParameters;
}



//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getParameters}} 
bool ShowFileReader::
getParameters(const aString & nameOfDirectory, ListOfShowFileParameters & params )
//----------------------------------------------------------------------
// /Description:
//    Get parameters from a given directory
// 
// /nameOfDirectory (input) : look for the parameters in this directory.
// /params (input): The parameters are returned here.
// 
// /return value: 
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  // const int first = 0;
  int fs = currentFrameSeries;
  GenericDataBase *dir = getFrame();
  assert( dir!=NULL );
  
  GenericDataBase & subDir = *dir->virtualConstructor();
  bool notFound = dir->locate(subDir,nameOfDirectory,"Parameters");
  if( notFound )
  {
    printF("ShowFileReader::getParameters: directory named [%s] was NOT found\n",(const char*)nameOfDirectory);
    return false;
  }

  int numberOfParameters=-1;
  subDir.turnOffWarnings();
  int returnValue = subDir.get(numberOfParameters,"numberOfParameters");
  subDir.turnOnWarnings();
  if( returnValue!=0 || numberOfParameters<=0 ) return false;
      
  // For now every parameter is potentially stored as an int, real or string
      
  int *type = new int [numberOfParameters];
  aString *name = new aString [numberOfParameters];  
  int *iv = new int [numberOfParameters];
  real *rv = new real [numberOfParameters];
  aString *sv = new aString [numberOfParameters];
      
  subDir.get(name,"name",numberOfParameters);
  subDir.get(type,"type",numberOfParameters);
  subDir.get(iv,"int",numberOfParameters);
  subDir.get(rv,"real",numberOfParameters);
  subDir.get(sv,"string",numberOfParameters);
      
  // listOfGeneralParameters[fs].clear();  // *wdh* 080530 -- do not clear general parameters ---
  ShowFileParameter sfp;
  for(int i=0; i<numberOfParameters; i++ )
  {
    if( false )
    {
      printF("ShowFile:getParameters:parameter %i: name=%s value=",i,(const char*)name[i]);
      if( type[i]==(int)ShowFileParameter::intParameter )
        printF("%i\n",iv[i]);
      else if( type[i]==(int)ShowFileParameter::realParameter )
        printF("%e\n",rv[i]);
      else
        printF("%s\n",(const char*)sv[i]);
    }
    
    sfp.set(name[i],(ShowFileParameter::ParameterType)type[i],iv[i],rv[i],sv[i]);
    params.push_back(sfp);
  }

  delete &subDir;
  delete [] type;
  delete [] name;
  delete [] iv;
  delete [] rv;
  delete [] sv;
      
  if( false )
  {
    if ( fs )
      printF(" %i general parameters were found in frame series %s\n",numberOfParameters,frameSeriesNames[fs-1].c_str());
    else
      printF(" %i general parameters were found in the show file\n",numberOfParameters);
  }
  
  return true;
}



//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{isAMovingGrid}} 
bool ShowFileReader::
isAMovingGrid()
//----------------------------------------------------------------------
// /Description:
//   Return TRUE if this is a moving grid problem
// /return value: Return TRUE if this is a moving grid problem
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  return movingGridProblem;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{open}} 
int ShowFileReader::
open(const aString & showFileName, const int displayInfo /* =1 */ )
//----------------------------------------------------------------------
// /Description:
//    Open a show file that was generated by Ogshow.
// /showFileName (input): name of an existing show file.
// /displayInfo (input) : if not equal to zero output info about the parameters in the file.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
//----------------------------------------------------------------------
{
  if( showFileIsOpen )
  {
    printF("ShowFileReader::open:ERROR: a show file is already open, call close first \n");
    Overture::abort("error");
  }
  
  nameOfShowFile=showFileName;
  
  // header comments are saved in the following array
  headerComment = new aString[maximumNumberOfHeaderComments];
  int n;
  for( n=0; n<maximumNumberOfHeaderComments; n++ )
    headerComment[n]=" ";


  if( displayInfo ) 
    printF("mount the showfile: %s\n",(const char *) nameOfShowFile);
  showFile = new DBPointer [maxNumberOfShowFiles];
  for( n=0; n<maxNumberOfShowFiles; n++ )
  {
    showFile[n]=NULL;
  }
  
  showFile[0] = new HDF_DataBase();  
  showFile[0]->turnOffWarnings();
  int found = showFile[0]->mount(nameOfShowFile,"R");  // mount show file read-only

  if( found!=0 )
  {
    nameOfShowFile = showFileName+".hdf";
    found = showFile[0]->mount(nameOfShowFile,"R");
    if( found!=0 )
    {
      nameOfShowFile = showFileName+".show";
      found = showFile[0]->mount(nameOfShowFile,"R");
      if( found!=0 )
      {
        printF("ShowFileReader::ERROR: unable to open an old file = %s (or %s) (or %s)\n",
               (const char *)showFileName,
               (const char *)(showFileName+".hdf"),
               (const char *)(showFileName+".show"));
        Overture::abort("error");
      }
    }
  }
  showFile[0]->turnOnWarnings();

  if( displayInfo )
    printF("mount the showfile... done. (file created with version %s, current version is %s)\n",
           (const char*)(showFile[0]->OvertureVersion),OVERTURE_VERSION);
  showFileIsOpen=true;

  // In parallel, with the GenericDataBase::multipleFileIO option, additional files are saved to hold local data. 
  // We need to decrease the maximum allowable number of open show files to account for these extra files.

  // get the maximum number of allowable open file descriptors: 
  rlimit rlim;
  getrlimit(RLIMIT_NOFILE,&rlim);

  int numberOfFilesForOthers=rlim.rlim_cur/2;  // how many file descriptors show we leave for others?
  maxNumberOfOpenFiles=rlim.rlim_cur-numberOfFilesForOthers;  // This limit may be about 1024.
  if( maxNumberOfOpenFiles<1 || maxNumberOfOpenFiles>100000 )
  {
    maxNumberOfOpenFiles=50;
    printF("ShowFileReader::open:WARNING: system returned the limit on file descriptors as %i\n",
           "  This seems wrong. I am going to set it to %i\n",(int)rlim.rlim_cur,maxNumberOfOpenFiles);
  }

//   int numberOfLocalFilesForReading = max(0, showFile[0]->getNumberOfLocalFilesForReading());
//   printF("ShowFileReader::open: DB: numberOfLocalFilesForReading=%i\n",numberOfLocalFilesForReading);
//   maxNumberOfOpenFiles = max(2, maxNumberOfOpenFiles/(numberOfLocalFilesForReading+1) );

  if( displayInfo )
    printF("ShowFileReader::open: File descriptor limits = %i, %i, setting maxNumberOfOpenFiles=%i.\n",
           (int)rlim.rlim_cur,(int)rlim.rlim_max,maxNumberOfOpenFiles);

  streamMode=true; // make this the default as it was the old way.
  showFile[0]->get(streamMode,"streamMode");
  if( !streamMode )
  {
    printF("ShowFileReader:INFO: this show file was not created with streamMode\n");
    showFile[0]->setMode(GenericDataBase::noStreamMode);
  }
//   else
//   {
//     printF("ShowFileReader:INFO: setMode(GenericDataBase::normalMode)\n");
//     showFile[0]->setMode(GenericDataBase::normalMode);
//   }
  
  int junk;
  showFile[0]->turnOffWarnings();
  int notAShowFile = showFile[0]->get(junk,"magicNumber");
  showFile[0]->turnOnWarnings();
  if( notAShowFile )
  {
    // printF("magicNumber not found: this could be a grid file with no solutions, ignore previous ERROR message\n");
    numberOfFrames=0;
    numberOfSolutions=1;
  }
  else
  {
    // Check to see if this is a show file with moving grids in it
    movingGridProblem=FALSE;  
    //kkc 061023    showFile[0]->get(movingGridProblem,"movingGridProblem"); 

//     // the first show file may be a sub-file from a multi-file 
//     int multiFile=false;
//     showFile[0]->get(multiFile,"multiFile"); 

    // This may be a multi-file showfile, so look for all sub-files
    int & numberOfValidFiles = dbase.get<int>("numberOfValidFiles");
    numberOfValidFiles = getNumberOfValidFiles(displayInfo);
    // count the total number of frames in the show file(s)
    countNumberOfFramesAndSolutions(displayInfo);

    // look for any general parameters associated with the file.
    getGeneralParameters(displayInfo);
  }

  return 0;
}
  

int ShowFileReader::
openShowFile(const int n)
// =============================================================================
// open the subfile numbered n
// return value 0 : open was succesful
// =============================================================================
{
  if( !showFileIsOpen )
  {
    printF("ShowFileReader::openShowFile:ERROR: you must first open a show file. \n");
    Overture::abort("error");
  }

  int returnValue=1;
  if( showFile[n]==NULL || showFile[n]->isNull() )
  {
    
    char buff[80];
    aString name = nameOfShowFile + sPrintF(buff,"%i",n);
    FILE *fp = fopen((const char *)name,"r");
    if( fp!=NULL )
    {
      fclose(fp);
      // cout << "Open the new show subfile called: " << name << endl;

      if( numberOfOpenFiles >= maxNumberOfOpenFiles ) 
      { // close an open file because we have too many
        for( int i=0; i<maxNumberOfShowFiles; i++ )
        {
          // look for a previous file to close
          int prev = max(1,maxNumberOfOpenFiles/5); 
          
          int m = (n-i-prev + 20*maxNumberOfShowFiles) % maxNumberOfShowFiles;
          if( showFile[m]!=NULL && !showFile[m]->isNull() &&
              m!=0 && m!=(numberOfShowFiles-1) )  // do not close the first or last file since we get info from it
          {
            printF("openShowFile: too many files, close file m=%i\n",m);
            showFile[m]->unmount(); 
            numberOfOpenFiles--;
            break;
          }
        }
      }

      if( showFile[n]==NULL )
        showFile[n] = new HDF_DataBase();
      returnValue = showFile[n]->mount(name,"R");

      if( n>0 && !streamMode )
        showFile[n]->setMode(GenericDataBase::noStreamMode);
      else
        showFile[n]->setMode(GenericDataBase::normalMode);

      numberOfOpenFiles++;
    }
    else
    {
      printF("openShowFile:ERROR file is not there!\n");
    }
  }
  else
  {
    printF("openShowFile:ERROR: showFile[n] is already open \n");
  }
  return returnValue;
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getNumberOfFrameSeries}} 
int ShowFileReader::
getNumberOfFrameSeries() const 
// ====================================================================================
//   /Description:
//     Return the number of frame series in the show file.
//
//  /Return value: 0 for success.
//  /Author: KKC
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  return frameSeriesNames.size();
}

//\begin{>>ShowFileReaderInclude.tex}{\subsubsection{getFrameSeriesName}} 
aString ShowFileReader::
getFrameSeriesName( const Ogshow::FrameSeriesID frame_series )
// ====================================================================================
//   /Description:
//     Return the string name of a particular frame series
//
// /frame\_series (input) : integer specifying the frame series
//
//  /Return value: the name of frame\_series on success, an null string ("") on failure
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  if ( frame_series<0 || frame_series>frameSeriesNames.size() )
    return "";
  
  return frameSeriesNames[frame_series];
}

int ShowFileReader::
setCurrentFrameSeries( const Ogshow::FrameSeriesID frame_series )
// ====================================================================================
//   /Description:
//     Return the data for a sequence.
//
// /name (output) : name of the sequence.
// /time (output) : time(0...n-1) - array of n 'time' values or other iteration variable.
// /value (output) : value(0...n-1,0..m-1) array of n values for each of m components.
// /componentName1 (output) : name1[0..m-1] name for the components.
// /maxComponentName1 (input) : maximum number of array elements in the array componentName1.
// /componentName2 (output) : names for a second level of components BUT DO NOT USE THIS for now.
// /maxComponentName2 (input) : maximum number of array elements in the array componentName2.
//
//  /Return value: 0 for success.
//  /Author: WDH
//\end{ShowFileReaderInclude.tex}
// ====================================================================================
{
  if ( frame_series<0 || frame_series>=frameSeriesNames.size() )
    return -1;
  
  frameSeriesInfo(currentFrameSeries, frameIDForGrid ) = frameNumberForGrid;
  
  currentFrameSeries = frame_series;
  numberOfFrames = frameSeriesInfo(currentFrameSeries,numFrames);
  numberOfSequences = frameSeriesInfo(currentFrameSeries,numSequences);
  numberOfSolutions = frameSeriesInfo(currentFrameSeries,numSolutions);
  movingGridProblem = frameSeriesInfo(currentFrameSeries,isMovingGrid);
  frameNumberForGrid= frameSeriesInfo(currentFrameSeries,frameIDForGrid);
  streamMode        = frameSeriesInfo(currentFrameSeries,streamModeOption);

  return 0;
}
